"""
Integration tests — end-to-end compositional function discovery.

These tests verify the full pipeline: Composer.fit() on data generated by
known functions, checking that the discovered expression is accurate.
"""

import unittest
import numpy as np

from agi_composer import Composer


class TestComposerIntegration(unittest.TestCase):
    """End-to-end tests for the Composer API."""

    def test_discover_linear(self):
        """Discover y = 2x + 1."""
        x = np.linspace(0, 10, 100)
        y = 2.0 * x + 1.0

        composer = Composer(seed=42, population_size=15)
        result = composer.fit(x, y, max_iterations=3000)

        self.assertGreater(result.r_squared, 0.99,
                           f"Linear: R²={result.r_squared:.4f}, expr={result.expression}")

    def test_discover_quadratic(self):
        """Discover y = x²."""
        x = np.linspace(-3, 3, 100)
        y = x ** 2

        composer = Composer(seed=123, beta=0.005)
        result = composer.fit(x, y, max_iterations=5000)

        self.assertGreater(result.r_squared, 0.95,
                           f"Quadratic: R²={result.r_squared:.4f}, expr={result.expression}")

    def test_discover_sin(self):
        """Discover y = sin(x)."""
        x = np.linspace(0, 2 * np.pi, 100)
        y = np.sin(x)

        composer = Composer(seed=42, beta=0.005, population_size=25)
        result = composer.fit(x, y, max_iterations=5000)

        self.assertGreater(result.r_squared, 0.90,
                           f"Sin: R²={result.r_squared:.4f}, expr={result.expression}")

    def test_predict_on_new_data(self):
        """Discovered expression should generalize to unseen x values."""
        x_train = np.linspace(0, 5, 80)
        y_train = 3.0 * x_train + 2.0

        composer = Composer(seed=42)
        result = composer.fit(x_train, y_train, max_iterations=3000)

        # Predict on unseen data
        x_test = np.linspace(5, 10, 50)
        y_test = 3.0 * x_test + 2.0
        y_pred = result.predict(x_test)

        mse = float(np.mean((y_pred - y_test) ** 2))
        self.assertLess(mse, 1.0,
                        f"Generalization failed: MSE={mse:.4f}")

    def test_fit_result_summary(self):
        """FitResult.summary() should return a non-empty string."""
        x = np.linspace(0, 3, 50)
        y = x * 2

        composer = Composer(seed=0)
        result = composer.fit(x, y, max_iterations=500)

        summary = result.summary()
        self.assertIsInstance(summary, str)
        self.assertIn("Expression", summary)
        self.assertIn("R²", summary)

    def test_constant_target(self):
        """Should handle constant target (y = 5)."""
        x = np.linspace(0, 10, 50)
        y = np.full_like(x, 5.0)

        composer = Composer(seed=42)
        result = composer.fit(x, y, max_iterations=2000)

        pred = result.predict(x)
        mse = float(np.mean((pred - y) ** 2))
        self.assertLess(mse, 1.0)


if __name__ == "__main__":
    unittest.main()
